var documenterSearchIndex = {"docs":
[{"location":"Distributed/#Distributed-computing","page":"Distributed computing","title":"Distributed computing","text":"","category":"section"},{"location":"Distributed/","page":"Distributed computing","title":"Distributed computing","text":"We support distributed computing through GridapDistributed.jl. As per usual, we design our libraries so that the high-level API is unchanged when using distributed computing. This means that for most users, the changes to your driver will be minimal.","category":"page"},{"location":"Distributed/","page":"Distributed computing","title":"Distributed computing","text":"The following features are currently supported:","category":"page"},{"location":"Distributed/","page":"Distributed computing","title":"Distributed computing","text":"Level-Set Cutters\nSTL Cutters","category":"page"},{"location":"Distributed/","page":"Distributed computing","title":"Distributed computing","text":"The folowing features are not yet supported:","category":"page"},{"location":"Distributed/","page":"Distributed computing","title":"Distributed computing","text":"Aggregated FEM\nMoment-Fitted Quadratures","category":"page"},{"location":"Interfaces/#Embedded-Interfaces","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"","category":"section"},{"location":"Interfaces/#Domain-Nomenclature","page":"Embedded Interfaces","title":"Domain Nomenclature","text":"","category":"section"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"Throughout this documentation, many methods accept arguments that select different parts of the cut domain. We split the domain into the following parts:","category":"page"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"The background mesh entities (cells, facets, nodes) are classified as IN, OUT or CUT. The IN and OUT background cells are uncut, i.e completely inside or outside the geometry, respectively. These states are internally defined as constants:","category":"page"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"  const IN = -1\n  const OUT = 1\n  const CUT = 0","category":"page"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"The CUT background cells are cut by the embedded boundary, and split into subcells/subfacets. The subcells/subfacets are classified as IN or OUT depending on whether they are inside or outside the geometry. CUT_IN and CUT_OUT subentities can be accessed using the CutInOrOut objects:","category":"page"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"  struct CutInOrOut\n    in_or_out::Int\n  end\n  const CUT_IN = CutInOrOut(IN)\n  const CUT_OUT = CutInOrOut(OUT)","category":"page"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"For FEM, we generally want to get sets of uncut and cut cells together, for a given state IN/OUT. These are referred as PHYSICAL parts of the domain. Moreover, FE spaces are generally defined over the background mesh and need to span both IN/OUT and CUT background cells. These are referred as ACTIVE parts of the domain. You can extract the PHYSICAL and ACTIVE parts of the domain using the following constants:","category":"page"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"const PHYSICAL_IN = (CUT_IN,IN)\nconst PHYSICAL_OUT = (CUT_OUT,OUT)\nconst PHYSICAL = PHYSICAL_IN","category":"page"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"struct ActiveInOrOut\n  in_or_out::Int\nend\nconst ACTIVE_IN = ActiveInOrOut(IN)\nconst ACTIVE_OUT = ActiveInOrOut(OUT)\nconst ACTIVE = ACTIVE_IN","category":"page"},{"location":"Interfaces/#Cutters","page":"Embedded Interfaces","title":"Cutters","text":"","category":"section"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"Cutters are used to cut the background mesh according to a provided geometry.","category":"page"},{"location":"Interfaces/#GridapEmbedded.Interfaces.Cutter","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.Cutter","text":"abstract type Cutter <: GridapType end\n\nAbstract type for all mesh cutters. Has to be paired with a CSG.Geometry to  cut the background mesh.\n\nMethods\n\ncut(cutter::Cutter,background,geom)\ncut_facets(cutter::Cutter,background,geom)\ncompute_bgcell_to_inoutcut(cutter::Cutter,background,geom)\ncompute_bgfacet_to_inoutcut(cutter::Cutter,background,geom)\n\nGenerally cut and cut_facets dispatch based on the geometry provided, so it is  generally more convennient to call the following methods instead:\n\ncut(background,geom)\ncut_facets(background,geom)\n\n\n\n\n\n","category":"type"},{"location":"Interfaces/#GridapEmbedded.Interfaces.compute_bgcell_to_inoutcut-Tuple{GridapEmbedded.Interfaces.Cutter, Any, Any}","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.compute_bgcell_to_inoutcut","text":"compute_bgcell_to_inoutcut(cutter::Cutter,background,geom)\n\nReturns an array of IN/OUT/CUT states for each cell in the background mesh.\n\n\n\n\n\n","category":"method"},{"location":"Interfaces/#GridapEmbedded.Interfaces.compute_bgfacet_to_inoutcut-Tuple{GridapEmbedded.Interfaces.Cutter, Any, Any}","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.compute_bgfacet_to_inoutcut","text":"compute_bgfacet_to_inoutcut(cutter::Cutter,background,geom)\n\nReturns an array of IN/OUT/CUT states for each facet in the background mesh.\n\n\n\n\n\n","category":"method"},{"location":"Interfaces/#GridapEmbedded.Interfaces.cut-Tuple{GridapEmbedded.Interfaces.Cutter, Any, Any}","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.cut","text":"cut(cutter::Cutter,background,geom)\n\nCut the background mesh with the provided cutter and geometry, returnning the cut cells. The cut cells are returned as an EmbeddedDiscretization object.\n\n\n\n\n\n","category":"method"},{"location":"Interfaces/#GridapEmbedded.Interfaces.cut_facets-Tuple{GridapEmbedded.Interfaces.Cutter, Any, Any}","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.cut_facets","text":"cut_facets(cutter::Cutter,background,geom)\n\nCut the background mesh with the provided cutter and geometry, returning the cut facets. The cut facets are returned as an EmbeddedFacetDiscretization object.\n\n\n\n\n\n","category":"method"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"We provide several types of cutters, including:","category":"page"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"Level-Set Cutters: Cutters for Level-Set and function-defined geometries. See Level-Set Cutters.\nSTL Cutters: Cutters for STL based geometries. Provided by STLCutters.jl.","category":"page"},{"location":"Interfaces/#Embedded-Discretizations","page":"Embedded Interfaces","title":"Embedded Discretizations","text":"","category":"section"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"After cutting the background mesh, you will be returned an EmbeddedDiscretization object. These contain all the information you need to generate the integration meshes for embedded methods.","category":"page"},{"location":"Interfaces/#GridapEmbedded.Interfaces.AbstractEmbeddedDiscretization","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.AbstractEmbeddedDiscretization","text":"abstract type EmbeddedDiscretization <: GridapType\n\n\n\n\n\n","category":"type"},{"location":"Interfaces/#GridapEmbedded.Interfaces.EmbeddedDiscretization","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.EmbeddedDiscretization","text":"struct EmbeddedDiscretization{Dc,T} <: AbstractEmbeddedDiscretization\n\nThis structure contains all the required information to build integration Triangulations  for a cut model.\n\nConstructors\n\ncut(cutter::Cutter,background,geom)\n\nProperties\n\nbgmodel::DiscreteModel: the background mesh\ngeo::CSG.Geometry: the geometry used to cut the background mesh\nsubcells::SubCellData: collection of cut subcells, attached to the background mesh\nsubfacets::SubFacetData: collection of cut facets, attached to the background mesh\nls_to_bgcell_to_inoutcut::Vector{Vector{Int8}}: list of IN/OUT/CUT states for each cell   in the background mesh, for each node in the geometry tree.\nls_to_subcell_to_inoutcut::Vector{Vector{Int8}}: list of IN/OUT/CUT states for each subcell   in the cut part of the mesh, for each node in the geometry tree.\nls_to_subfacet_to_inoutcut::Vector{Vector{Int8}}: list of IN/OUT/CUT states for each subfacet   in the cut part of the mesh, for each node in the geometry tree.\n\nMethods\n\nTriangulation(cut::EmbeddedDiscretization,in_or_out)\nEmbeddedBoundary(cut::EmbeddedDiscretization)\nGhostSkeleton(cut::EmbeddedDiscretization)\n\n\n\n\n\n","category":"type"},{"location":"Interfaces/#GridapEmbedded.Interfaces.EmbeddedFacetDiscretization","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.EmbeddedFacetDiscretization","text":"struct EmbeddedFacetDiscretization{Dc,Dp,T} <: AbstractEmbeddedDiscretization\n\nThis structure contains all the required information to build integration Triangulations  for a cut model boundary.\n\nConstructors\n\ncut_facets(cutter::Cutter,background,geom)\n\nProperties\n\nbgmodel::DiscreteModel: the background mesh\ngeo::CSG.Geometry: the geometry used to cut the background mesh\nsubfacets::SubFacetData: collection of cut facets, attached to the background mesh\nls_to_facet_to_inoutcut::Vector{Vector{Int8}}: list of IN/OUT/CUT states for each facet   in the background mesh, for each node in the geometry tree.\nls_to_subfacet_to_inoutcut::Vector{Vector{Int8}}: list of IN/OUT/CUT states for each subfacet   in the cut part of the mesh, for each node in the geometry tree.\n\nMethods\n\nBoundaryTriangulation(cut::EmbeddedFacetDiscretization,in_or_out)\nSkeletonTriangulation(cut::EmbeddedFacetDiscretization,in_or_out)\n\n\n\n\n\n","category":"type"},{"location":"Interfaces/#Embedded-Triangulations","page":"Embedded Interfaces","title":"Embedded Triangulations","text":"","category":"section"},{"location":"Interfaces/","page":"Embedded Interfaces","title":"Embedded Interfaces","text":"From EmbeddedDiscretization objects, you can extract all the triangulations you need to perform integration for embedded methods. We currently provide the following methods:","category":"page"},{"location":"Interfaces/#Gridap.Geometry.Triangulation-Tuple{EmbeddedDiscretization, Any}","page":"Embedded Interfaces","title":"Gridap.Geometry.Triangulation","text":"Triangulation(cut::EmbeddedDiscretization[,in_or_out=PHYSICAL_IN])\n\nCreates a triangulation containing the cell and subcells of the embedded domain selected by  in_or_out.\n\nIf only background cells are selected, the result will be a regular Gridap triangulation.\nIf only subcells are selected, the result will be a SubCellTriangulation.\nIf both background cells and subcells are selected, the result will be an AppendedTriangulation,  containing a SubCellTriangulation and a regular Gridap triangulation.\n\n\n\n\n\n","category":"method"},{"location":"Interfaces/#GridapEmbedded.Interfaces.EmbeddedBoundary-Tuple{EmbeddedDiscretization}","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.EmbeddedBoundary","text":"EmbeddedBoundary(cut::EmbeddedDiscretization)\n\nCreates a triangulation containing the cut facets of the embedded domain boundary. The result is a SubFacetTriangulation.\n\n\n\n\n\n","category":"method"},{"location":"Interfaces/#GridapEmbedded.Interfaces.GhostSkeleton-Tuple{EmbeddedDiscretization}","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.GhostSkeleton","text":"GhostSkeleton(cut::EmbeddedDiscretization[,in_or_out=ACTIVE_IN])\n\nCreates a triangulation containing the ghost facets. Ghosts facets are defined as the facets  of the background mesh that are adjacent to at least one CUT background cell.\n\nMostly used for CUT-FEM stabilisation. \n\n\n\n\n\n","category":"method"},{"location":"Interfaces/#Gridap.Geometry.BoundaryTriangulation-Tuple{GridapEmbedded.Interfaces.EmbeddedFacetDiscretization, Any}","page":"Embedded Interfaces","title":"Gridap.Geometry.BoundaryTriangulation","text":"BoundaryTriangulation(cut::EmbeddedFacetDiscretization[, in_or_out=PHYSICAL_IN; tags=nothing])\n\n\n\n\n\n","category":"method"},{"location":"Interfaces/#Gridap.Geometry.SkeletonTriangulation-Tuple{GridapEmbedded.Interfaces.EmbeddedFacetDiscretization, Any}","page":"Embedded Interfaces","title":"Gridap.Geometry.SkeletonTriangulation","text":"SkeletonTriangulation(cut::EmbeddedFacetDiscretization[, in_or_out=PHYSICAL_IN])\n\n\n\n\n\n","category":"method"},{"location":"Interfaces/#GridapEmbedded.Interfaces.SubCellTriangulation","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.SubCellTriangulation","text":"struct SubCellTriangulation{Dc,Dp} <: Triangulation{Dc,Dp}\n\nA triangulation for subcells. \n\n\n\n\n\n","category":"type"},{"location":"Interfaces/#GridapEmbedded.Interfaces.SubFacetTriangulation","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.SubFacetTriangulation","text":"struct SubFacetTriangulation{Dc,Dp,T,A} <: Triangulation{Dc,Dp}\n\nA triangulation for subfacets.\n\n\n\n\n\n","category":"type"},{"location":"Interfaces/#GridapEmbedded.Interfaces.SubFacetBoundaryTriangulation","page":"Embedded Interfaces","title":"GridapEmbedded.Interfaces.SubFacetBoundaryTriangulation","text":"struct SubFacetBoundaryTriangulation{Dc,Dp,T} <: Triangulation{Dc,Dp}\n\nTriangulation of cut facets from the background mesh, i.e each of the facets  in this triangulation is part of a background facet that has been cut by the geometry.\n\nThis differs from the the SubFacetTriangulation in that the facets in the SubFacetTriangulation  are not cut background facets, but rather subfacets on the interior of a background cell.\n\nThey result from calling Boundary or Skeleton on an EmbeddedFacetDiscretization object.\n\nBoundaryTriangulation(cut::EmbeddedFacetDiscretization,in_or_out;tags=nothing)\nSkeletonTriangulation(cut::EmbeddedFacetDiscretization,in_or_out)\n\n\n\n\n\n","category":"type"},{"location":"GeometricalDerivatives/#Geometrical-Derivatives","page":"Geometrical Derivatives","title":"Geometrical Derivatives","text":"","category":"section"},{"location":"GeometricalDerivatives/","page":"Geometrical Derivatives","title":"Geometrical Derivatives","text":"The geometrical differentiation capabilities are based on the following work:","category":"page"},{"location":"GeometricalDerivatives/","page":"Geometrical Derivatives","title":"Geometrical Derivatives","text":"note: Reference\n\"Level-set topology optimisation with unfitted finite elements and automatic shape differentiation\", by Z. J. Wegert, J. Manyer, C. Mallon, S. Badia, V. J. Challis (2025)","category":"page"},{"location":"GeometricalDerivatives/","page":"Geometrical Derivatives","title":"Geometrical Derivatives","text":"To see examples of usage, please refer to the tests in test/LevelSetCuttersTests/GeometricalDifferentiationTests.jl.","category":"page"},{"location":"GeometricalDerivatives/#Discretize-then-differentiate","page":"Geometrical Derivatives","title":"Discretize then differentiate","text":"","category":"section"},{"location":"GeometricalDerivatives/#GridapEmbedded.Interfaces.CutFaceBoundaryTriangulation","page":"Geometrical Derivatives","title":"GridapEmbedded.Interfaces.CutFaceBoundaryTriangulation","text":"struct CutFaceBoundaryTriangulation{Di,Df,Dp} <: Triangulation{Di,Dp}\n\nTriangulation containing the interfaces between subfacets. We always have dimensions\n\nDc :: Dimension of the background mesh\nDf = Dc-1 :: Dimension of the cut subfacets\nDi = Dc-2 :: Dimension of the subfacet interfaces\n\nProperties\n\nface_trian :: Original SubFacetTriangulation, built on top of the background mesh.\nface_model :: Subfacet model. Active model for face_trian.\nface_boundary :: Triangulation of the interfaces between subfacets. It is glued to the face_model.\ncell_boundary :: Conceptually the same as face_boundary, but it is glued to the background mesh cells. Created as a CompositeTriangulation between face_trian and face_boundary.\nghost_boundary :: Triangulation of the background facets that contain each interface.\n\nThe \"real\" triangulation is cell_boundary, but we require the other triangulations to perform complex changes of domain. Most of the Triangulation API is delegated to cell_boundary.\n\nConstructors\n\nBoundary(face_trian::SubFacetTriangulation)\nSkeleton(face_trian::SubFacetTriangulation)\n\n\n\n\n\n","category":"type"},{"location":"GeometricalDerivatives/#GridapEmbedded.Interfaces.get_ghost_mask-Union{Tuple{GridapEmbedded.Interfaces.SubFacetTriangulation{Df, Dc}}, Tuple{Dc}, Tuple{Df}, Tuple{GridapEmbedded.Interfaces.SubFacetTriangulation{Df, Dc}, Any}} where {Df, Dc}","page":"Geometrical Derivatives","title":"GridapEmbedded.Interfaces.get_ghost_mask","text":"get_ghost_mask(\n  face_trian::SubFacetTriangulation{Df,Dc},\n  face_model = get_active_model(face_trian)\n) where {Df,Dc}\n\nReturns a mask for ghost faces. We define ghost faces as the interfaces between two different cut facets that are located in different background cells.\n\nThe second condition is important: In 3D, some cuts subcells may not be simplices. In this case, we simplexify the subcell. This creates extra cut interfaces that are interior to a background cell. These are not considered ghost faces.\n\nIn 2D: Dc = 2, Df = 1 -> Ghost faces have dimension 0 (i.e interface points)\nIn 3D: Dc = 3, Df = 2 -> Ghost faces have dimension 1 (i.e interface edges)\n\n\n\n\n\n","category":"method"},{"location":"GeometricalDerivatives/#Autodiff","page":"Geometrical Derivatives","title":"Autodiff","text":"","category":"section"},{"location":"GeometricalDerivatives/#GridapEmbedded.LevelSetCutters.DifferentiableTriangulation","page":"Geometrical Derivatives","title":"GridapEmbedded.LevelSetCutters.DifferentiableTriangulation","text":"mutable struct DifferentiableTriangulation{Dc,Dp} <: Triangulation{Dc,Dp}\n\nA DifferentiableTriangulation is a wrapper around an embedded triangulation (i.e SubCellTriangulation or SubFacetTriangulation) implementing all the necessary methods to compute derivatives w.r.t. deformations of the embedded mesh.\n\nTo do so, it propagates dual numbers into the geometric maps mapping cut subcells/subfacets to the background mesh.\n\nConstructor:\n\nDifferentiableTriangulation(trian::Triangulation,fe_space::FESpace)\n\nwhere trian must be an embedded triangulation and fe_space is the FESpace where the level-set function lives.\n\n\n\n\n\n","category":"type"},{"location":"GeometricalDerivatives/#GridapEmbedded.LevelSetCutters.precompute_cut_edge_ids-Union{Tuple{Tp}, Tuple{Dp}, Tuple{Vector{<:Gridap.TensorValues.VectorValue{Dp, Tp}}, Vector{<:Gridap.TensorValues.VectorValue{Dp, Tp}}, Vector{<:Vector{<:Integer}}}} where {Dp, Tp}","page":"Geometrical Derivatives","title":"GridapEmbedded.LevelSetCutters.precompute_cut_edge_ids","text":"precompute_cut_edge_ids(rcoords,bg_rcoords,edge_list)\n\nGiven\n\nrcoords: the node ref coordinates of the cut subcell/subfacet,\nbg_rcoords: the node ref coordinates of the background cell containing it,\nedge_list: the list of nodes defining each edge of the background cell,\n\nthis function returns a vector that for each node of the cut subcell/subfacet contains\n\n-1 if the node is also a node of the background cell,\nthe id of the edge containing the node otherwise.\n\n\n\n\n\n","category":"method"},{"location":"LevelSetCutters/#Level-Set-Cutters","page":"Level Set Cutters","title":"Level-Set Cutters","text":"","category":"section"},{"location":"LevelSetCutters/#GridapEmbedded.LevelSetCutters.AnalyticalGeometry","page":"Level Set Cutters","title":"GridapEmbedded.LevelSetCutters.AnalyticalGeometry","text":"struct AnalyticalGeometry <: CSG.Geometry\n  tree::Node\nend\n\nA structure to represent analytical geometries, used to cut background meshes.\n\nConstructor\n\nAnalyticalGeometry(f::Function;name=string(nameof(f)))\n\nwhere f: Ω -> R is a function that, similiarly to a level set function, is negative inside the geometry and positive outside.\n\nPredefined geometries\n\ndoughnut(R,r;x0=zero(Point{3,typeof(R)}),name=\"doughnut\")\npopcorn(r0=0.6, σ=0.2, A=2, x0=zero(Point{3,typeof(r0)}), name=\"popcorn\")\nsphere(R;x0=zero(Point{3,eltype(R)}),name=\"sphere\")\ndisk(R;x0=zero(Point{2,eltype(R)}),name=\"disk\")\ncylinder(R;x0=zero(Point{3,eltype(R)}),v=VectorValue(1,0,0),name=\"cylinder\")\nplane(x0=Point(0,0,0),v=VectorValue(1,0,0),name=\"plane\")\nsquare(L=1,x0=Point(0,0),name=\"square\",edges=[\"edge_i\" for i in 1:4])\nquadrilateral(x0=Point(0,0),d1=VectorValue(1,0),d2=VectorValue(0,1),name=\"quadrilateral\")\ncube(L=1,x0=Point(0,0,0),name=\"cube\")\ntube(R,L;x0=zero(Point{3,typeof(R)}),v=VectorValue(1,0,0),name=\"tube\")\nolympic_rings(R,r,name=\"olympic_rings\")\n\n\n\n\n\n","category":"type"},{"location":"LevelSetCutters/#GridapEmbedded.LevelSetCutters.DiscreteGeometry","page":"Level Set Cutters","title":"GridapEmbedded.LevelSetCutters.DiscreteGeometry","text":"struct DiscreteGeometry{D,T} <: CSG.Geometry\n  tree::Node\n  point_to_coords::Vector{Point{D,T}}\nend\n\nConstructors\n\nDiscreteGeometry(φh::FEFunction,model::DiscreteModel;name::String=\"\")\nDiscreteGeometry(f::Function,model::DiscreteModel;name::String=\"\")\n\n\n\n\n\n","category":"type"},{"location":"LevelSetCutters/#GridapEmbedded.LevelSetCutters.LevelSetCutter","page":"Level Set Cutters","title":"GridapEmbedded.LevelSetCutters.LevelSetCutter","text":"struct LevelSetCutter <: Cutter end\n\nCutter for DiscreteGeometry and AnalyticalGeometry.\n\nUsage\n\ncut(background::DiscreteModel,geom::AnalyticalGeometry)\ncut(background::DiscreteModel,geom::DiscreteGeometry)\ncut_facets(background::DiscreteModel,geom::AnalyticalGeometry)\ncut_facets(background::DiscreteModel,geom::DiscreteGeometry)\n\n\n\n\n\n","category":"type"},{"location":"AggregatedFEM/#Aggregated-FEM","page":"Aggregated FEM","title":"Aggregated FEM","text":"","category":"section"},{"location":"MomentFittedQuadratures/#Moment-Fitted-Quadratures","page":"Moment-Fitted Quadratures","title":"Moment-Fitted Quadratures","text":"","category":"section"},{"location":"#GridapEmbedded.jl","page":"Home","title":"GridapEmbedded.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GridapEmbedded.jl is a package for the simulation of PDEs on embedded domains within the Gridap.jl ecosystem. Please refer to the Gridap.jl documentation for information on the core capabilities of the Gridap.jl library.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"CSG.md\",\n  \"Interfaces.md\",\n  \"LevelSetCutters.md\",\n  \"AggregatedFEM.md\",\n  \"MomentFittedQuadratures.md\",\n  \"GeometricalDerivatives.md\",\n  \"Distributed.md\",\n]","category":"page"},{"location":"CSG/#Constructive-Solid-Geometry-(CSG)","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"","category":"section"},{"location":"CSG/#GridapEmbedded.CSG.Geometry","page":"Constructive Solid Geometry (CSG)","title":"GridapEmbedded.CSG.Geometry","text":"abstract type Geometry\n\nAbstract type for the definition of a geometry.\n\nInterface\n\nget_tree(geo::Geometry)\nsimilar_geometry(a::Geometry,tree::Node)\ncompatible_geometries(a::Geometry,b::Geometry)\n\n\n\n\n\n","category":"type"},{"location":"CSG/#Base.:!-Tuple{GridapEmbedded.CSG.Geometry}","page":"Constructive Solid Geometry (CSG)","title":"Base.:!","text":"Base.:!(a::Geometry;name::String=\"\",meta=nothing)\n\n\n\n\n\n","category":"method"},{"location":"CSG/#Base.intersect-Tuple{GridapEmbedded.CSG.Geometry, GridapEmbedded.CSG.Geometry}","page":"Constructive Solid Geometry (CSG)","title":"Base.intersect","text":"Base.intersect(a::Geometry,b::Geometry;name::String=\"\",meta=nothing)\n\n\n\n\n\n","category":"method"},{"location":"CSG/#Base.setdiff-Tuple{GridapEmbedded.CSG.Geometry, GridapEmbedded.CSG.Geometry}","page":"Constructive Solid Geometry (CSG)","title":"Base.setdiff","text":"Base.setdiff(a::Geometry,b::Geometry;name::String=\"\",meta=nothing)\n\n\n\n\n\n","category":"method"},{"location":"CSG/#Base.union-Tuple{GridapEmbedded.CSG.Geometry, GridapEmbedded.CSG.Geometry}","page":"Constructive Solid Geometry (CSG)","title":"Base.union","text":"Base.union(a::Geometry,b::Geometry;name::String=\"\",meta=nothing)\n\n\n\n\n\n","category":"method"},{"location":"CSG/#GridapEmbedded.CSG.compatible_geometries-Tuple{GridapEmbedded.CSG.Geometry, GridapEmbedded.CSG.Geometry}","page":"Constructive Solid Geometry (CSG)","title":"GridapEmbedded.CSG.compatible_geometries","text":"compatible_geometries(a::Geometry,b::Geometry)\n\n\n\n\n\n","category":"method"},{"location":"CSG/#GridapEmbedded.CSG.get_tree-Tuple{GridapEmbedded.CSG.Geometry}","page":"Constructive Solid Geometry (CSG)","title":"GridapEmbedded.CSG.get_tree","text":"get_tree(geo::Geometry)\n\n\n\n\n\n","category":"method"},{"location":"CSG/#GridapEmbedded.CSG.similar_geometry-Tuple{GridapEmbedded.CSG.Geometry, GridapEmbedded.CSG.Node}","page":"Constructive Solid Geometry (CSG)","title":"GridapEmbedded.CSG.similar_geometry","text":"similar_geometry(a::Geometry,tree::Node)\n\n\n\n\n\n","category":"method"}]
}
